http://judy.sourceforge.net/doc/10minutes.htm
http://www.nothings.org/computer/judy/
	Judy trees

maybe use a 4-bit tri to lookup IP addresses

http://www.postfix.org/SMTPD_POLICY_README.html
http://www.sendmail.org/doc/sendmail-current/libmilter/docs/

-------------

http://www.policyd.org/features.html	posfix
http://www.tahina.priv.at/~cm/spam/	postfix
http://hcpnet.free.fr/milter-greylist/	sendmail
http://www.acme.com/software/graymilter/ sendmail (only IP)


http://lists.puremagic.com/pipermail/greylist-users/2005-September/000995.html

points at which we can check for spam:

at connect time
prior to HELO
HELO response
MAIL FROM
RCPT TO
DATA






Okay, the way Postfix does things, it screws the pooch.  So, reorg time.

On the postfix side:

	while(1)
	{
		name = LineRead(STDIN);
		value = strchr(name,'=');
		eos   = strchr(value,'\n');
		*value++ = '\0';
		*eos     = '\0';

		// pull out request, from, to, ip
		if (all_data) break;
	}

	// package it up in a UDP packet
	// fire it off to the graylist daemon host
	// wait up to 10 seconds for the response

	if (okay)
		LineSFormat(STDOUT,"permit blah blah");
	else
		LineSFormat(STDOUT,"dunno");

On the daemon side:

	while(1)
	{
		packet = recieve();
		t = tuple_lookup(packet.ip,packet.from,packet.to);
		if (t == nil)
			create_tuple(t);
		else
			// rest of logic
	}

The packet:

struct graylist_request
{
  uint16 version;
  uint16 MTA;
  uint16 type;			/* 0 - graylist query */
  uint16 ipsize;
  uint16 fromsize;
  uint16 tosize;
  uint8  ip  [ipsize];
  char   from[fromsize];	/* '\0' terminated-not included in size */
  char   to  [tosize];		/* '\0' terminated-not included in size */
};


the return packet

struct graylist_reply
{
  uint16 version;
  uint16 MTA;
  uint16 type;		/* 1 - graylist response */
  uint16 response;	/* 0 - whitelist, >0 - graylist */
};

future revisions?

struct graylist_banip
{
  uint16 version;
  uint16 MTA;
  uint16 type;		/* 2 - banip - 3 - banip-rep */
  uint16 ipsize;
  uint8  ip[ipsize];
};

struct graylist_banfrom
{
  uint16 version;
  uint16 MTA;
  uint16 type;		/* 3 - banfrom - 4 - banfrom-rep */
  uint16 fromsize;
  char   from[fromsize];	/* ASCII0 */
};

------------

Look at using SA_RESTART for signals.

use pipe() to create a pipe.  epoll() on the read end. have the signals that
do stuff other than exit, write the signal number to the write end of the
pipe.  The readend gets notified of data, and we dispatch on that.  That
way, we don't have to busy-check the signals we're interested in.


format for whitelist:
	time ip from to
	...

reading in whitelist:

	Zen = mtime of tile
	Tao = now
	d   = Tao - Zen

	for each entry in whitelist
		read in
		adjust time by d
		if > c_timeout_whitelist reject

